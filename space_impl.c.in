// File created: 2011-08-06 15:45:41

#include "space_impl.h"

#include <stdbool.h>
#include <string.h>

#include "anamnesic_ring.h"
#include "aabb.h"
#include "bakaabb.h"
#include "coords.h"
#include "staticaabb.h"
#include "stats.h"

struct mushspace {
	mush_anamnesic_ring recent_buf;
	bool just_placed_big;
	mushcoords big_sequence_start, first_placed_big;

	void (*invalidatees)(void*);

	mushcoords last_beg, last_end;

	size_t box_count;

	mush_aabb    *boxen;
	mush_bakaabb *bak;
	mushstats    *stats;

	mush_staticaabb static_box;
};

#define mushspace_find_box MUSHSPACE_CAT(mushspace,_find_box)
static bool mushspace_find_box(
	const mushspace*, mushcoords, const mush_aabb**);

size_t MUSHSPACE_CAT(mushspace,_size)(void) { return sizeof(mushspace); }

mushspace* MUSHSPACE_CAT(mushspace,_allocate)(void* vp, mushstats* stats) {
	mushspace *space = vp ? vp : malloc(sizeof *space);
	if (space) {
		space->box_count = 0;

		space->boxen = NULL;
		space->bak   = NULL;
		space->stats = stats ? stats : malloc(sizeof *space->stats);

		mush_anamnesic_ring_init(&space->recent_buf);

		memset(space->static_box.array, ' ', sizeof space->static_box.array);
	}
	return space;
}

void MUSHSPACE_CAT(mushspace,_free)(mushspace* space) {
	for (size_t i = space->box_count; i--;)
		free(space->boxen[i].data);
	free(space->boxen);
	free(space->stats);
}

mushcell mushspace_get(mushspace* space, mushcoords c) {
	++space->stats->lookups;
	if (mush_staticaabb_contains(c))
		return mush_staticaabb_get(&space->static_box, c);

	const mush_aabb* box;
	if (mushspace_find_box(space, c, &box))
		return mush_aabb_get(box, c);

	if (space->bak)
		return mush_bakaabb_get(space->bak, c);

	return ' ';
}

static bool mushspace_find_box(
	const mushspace* space, mushcoords c, const mush_aabb** box)
{
	for (size_t i = 0; i < space->box_count; ++i) {
		if (mush_aabb_contains(&space->boxen[i], c)) {
			*box = &space->boxen[i];
			return true;
		}
	}
	return false;
}

#if MUSHSPACE_93
static void mushspace_bef93load_string(mushspace*, const char*, size_t len);
#endif

void MUSHSPACE_CAT(mushspace,_load_string)(
	mushspace* space, const char* str, size_t len
#if !MUSHSPACE_93
	, mushcoords* end, mushcoords target, bool binary
#endif
	)
{
#if MUSHSPACE_93
	mushspace_bef93load_string(space, str, len);
#else
#endif
}

#if MUSHSPACE_93
static bool mushspace_bef93newline(bool* got_cr, mushcoords* pos) {
	*got_cr = false;
	pos->x = 0;
	return ++pos->y >= 25;
}
static void mushspace_bef93load_string(
	mushspace* space, const char* str, size_t len)
{
	bool got_cr = false;
	mushcoords pos = MUSHCOORDS(0,0,0);

	for (size_t i = 0; i < len; ++i) {
		char c = str[i];

		switch (c) {
		case '\r': got_cr = true; break;
		case '\n': if (mushspace_bef93newline(&got_cr, &pos)) return; break;
		default:
			if (got_cr && mushspace_bef93newline(&got_cr, &pos))
				return;

			if (c != ' ')
				mush_staticaabb_put(&space->static_box, pos, c);

			if (++pos.x < 80)
				break;

			// Skip to and past EOL after column 80.
			while (++i < len) {
				c = str[i];
				switch (c) {
				case '\r': got_cr = true; break;
				default:   if (!got_cr) break;
				case '\n': if (mushspace_bef93newline(&got_cr, &pos)) return;
				           goto skipped;
				}
			}
skipped:
			break;
		}
	}
}
#endif
