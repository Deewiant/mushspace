// File created: 2011-08-06 15:45:41

#include "space_impl.h"

#include <stdbool.h>
#include <string.h>

#include "anamnesic_ring.h"
#include "aabb.h"
#include "bakaabb.h"
#include "coords.h"
#include "staticaabb.h"
#include "stats.h"

struct mushspace {
	mush_anamnesic_ring recent_buf;
	bool just_placed_big;
	mushcoords big_sequence_start, first_placed_big;

	void (*invalidatees)(void*);

	mushcoords last_beg, last_end;

	size_t box_count;

	mush_aabb    *boxen;
	mush_bakaabb *bak;
	mush_stats   *stats;

	mush_staticaabb static_box;
};

#define mushspace_find_box MUSHSPACE_CAT(mushspace,_find_box)
static bool mushspace_find_box(
	const mushspace*, mushcoords, const mush_aabb**);

size_t MUSHSPACE_CAT(mushspace,_size)(void) { return sizeof(mushspace); }

mushspace* MUSHSPACE_CAT(mushspace,_allocate)(void* vp, mush_stats* stats) {
	mushspace *space = vp ? vp : malloc(sizeof *space);
	if (space) {
		space->box_count = 0;

		space->boxen = NULL;
		space->bak   = NULL;
		space->stats = stats ? stats : malloc(sizeof *space->stats);

		mush_anamnesic_ring_init(&space->recent_buf);

		memset(space->static_box.array, ' ', sizeof space->static_box.array);
	}
	return space;
}

void MUSHSPACE_CAT(mushspace,_free)(mushspace* space) {
	for (size_t i = space->box_count; i--;)
		free(space->boxen[i].data);
	free(space->boxen);
	free(space->stats);
}

mushcell mushspace_get(mushspace* space, mushcoords c) {
	++space->stats->lookups;
	if (mush_staticaabb_contains(c))
		return mush_staticaabb_get(&space->static_box, c);

	const mush_aabb* box;
	if (mushspace_find_box(space, c, &box))
		return mush_aabb_get(box, c);

	return ' ';
}

static bool mushspace_find_box(
	const mushspace* space, mushcoords c, const mush_aabb** box)
{
	for (size_t i = 0; i < space->box_count; ++i) {
		if (mush_aabb_contains(&space->boxen[i], c)) {
			*box = &space->boxen[i];
			return true;
		}
	}
	return false;
}
