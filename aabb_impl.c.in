// File created: 2011-08-06 17:57:52

#include "aabb_impl.h"

#include <assert.h>
#include <string.h>

void mush_aabb_make(mush_aabb* aabb, mushcoords b, mushcoords e) {
	for (mushdim i = 0; i < MUSHSPACE_DIM; ++i)
		assert (b.v[i] <= e.v[i]);

	mush_aabb_make_unsafe(aabb, b, e);
	mush_aabb_finalize(aabb);
}

void mush_aabb_make_unsafe(mush_aabb* aabb, mushcoords b, mushcoords e) {
	*aabb = (mush_aabb){.beg = b, .end = e};
}

void mush_aabb_finalize(mush_aabb* aabb) {
	aabb->size = aabb->end.x - aabb->beg.x + 1;

#if MUSHSPACE_DIM >= 2
	aabb->width = aabb->size;
	aabb->size *= aabb->end.y - aabb->beg.y + 1;
#endif
#if MUSHSPACE_DIM >= 3
	aabb->area  = aabb->size;
	aabb->size *= aabb->end.z - aabb->beg.z + 1;
#endif
}

bool mush_aabb_alloc(mush_aabb* aabb) {
	aabb->data = malloc(aabb->size);
	if (!aabb->data)
		return false;
	memset(aabb->data, ' ', aabb->size);
	return true;
}

size_t mush_aabb_volume_on(const mush_aabb* aabb, mushdim axis) {
	assert (axis < MUSHSPACE_DIM);
#if MUSHSPACE_DIM >= 2
	if (axis == 1) return aabb->width;
#if MUSHSPACE_DIM >= 3
	if (axis == 2) return aabb->area;
#endif
#endif
	(void)aabb; (void)axis;
	return 1;
}

mushcell mush_aabb_get(const mush_aabb* aabb, mushcoords c) {
	assert (mush_aabb_contains(aabb, c));
	return aabb->data[mush_aabb_get_idx(aabb, c)];
}

void mush_aabb_put(mush_aabb* aabb, mushcoords p, mushcell c) {
	assert (mush_aabb_contains(aabb, p));
	aabb->data[mush_aabb_get_idx(aabb, p)] = c;
}

bool mush_aabb_contains(const mush_aabb* aabb, mushcoords c) {
	return mushcoords_contains(c, aabb->beg, aabb->end);
}

bool mush_aabb_safe_contains(const mush_aabb* aabb, mushcoords c) {
	for (mushdim i = 0; i < MUSHSPACE_DIM; ++i) {
		if (aabb->beg.v[i] > aabb->end.v[i]) {
			if (!(c.v[i] >= aabb->beg.v[i] || c.v[i] <= aabb->end.v[i]))
				return false;
		} else
			if (!(c.v[i] >= aabb->beg.v[i] && c.v[i] <= aabb->end.v[i]))
				return false;
	}
	return true;
}

size_t mush_aabb_get_idx(const mush_aabb* aabb, mushcoords c) {
	return mush_aabb_get_idx_no_offset(aabb, mushcoords_sub(c, aabb->beg));
}
size_t mush_aabb_get_idx_no_offset(const mush_aabb* aabb, mushcoords c)
{
	size_t i = c.x;
#if MUSHSPACE_DIM >= 2
	i += aabb->width * c.y;
#if MUSHSPACE_DIM >= 3
	i += aabb->area  * c.z;
#endif
#else
	(void)aabb;
#endif
	return i;
}

bool mush_aabb_overlaps(const mush_aabb* a, const mush_aabb* b) {
	for (mushdim i = 0; i < MUSHSPACE_DIM; ++i)
		if (a->beg.v[i] > b->end.v[i] || b->beg.v[i] > a->end.v[i])
			return false;
	return true;
}

bool mush_aabb_contains_box(const mush_aabb* a, const mush_aabb* b) {
	return mush_aabb_contains(a, b->beg) && mush_aabb_contains(a, b->end);
}

// Modifies the given beg/end pair to give a box which contains the given
// coordinates but doesn't overlap with any of the given boxes. The coordinates
// should, of course, be already contained between the beg and end.
void mush_aabb_tessellate(
	mushcoords pos, const mush_aabb* bs, size_t len,
	mushcoords* beg, mushcoords* end)
{
	assert (mushcoords_contains(pos, *beg, *end));

	for (size_t i = 0; i < len; ++i)
		mush_aabb_tessellate1(pos, bs[i].beg, bs[i].end, beg, end);
}

// Since the algorithm is currently just a fold over the boxes, this simpler
// version exists to avoid heap allocation in some cases.
void mush_aabb_tessellate1(
	mushcoords pos, mushcoords avoid_beg, mushcoords avoid_end,
	mushcoords* beg, mushcoords* end)
{
	assert (mushcoords_contains(pos, *beg, *end));

	for (mushdim i = 0; i < MUSHSPACE_DIM; ++i) {
		// This could be improved, consider for instance the bottommost box in
		// the following graphic and its current tessellation:
		//
		// +-------+    +--*--*-+
		// |       |    |X .  . |
		// |       |    |  .  . |
		// |     +---   *..*..+---
		// |     |      |  .  |
		// |  +--|      *..+--|
		// |  |  |      |  |  |
		// |  |  |      |  |  |
		// +--|  |      +--|  |
		//
		// (Note that this isn't actually a tessellation: all points will get
		// a rectangle containing the rectangle at X.)
		//
		// Any of the following three would be an improvement (and they would
		// actually be tessellations):
		//
		// +--*--*-+    +-------+    +-----*-+
		// |  .  . |    |       |    |     . |
		// |  .  . |    |       |    |     . |
		// |  .  +---   *.....+---   |     +---
		// |  .  |      |     |      |     |
		// |  +--|      *..+--|      *..+--|
		// |  |  |      |  |  |      |  |  |
		// |  |  |      |  |  |      |  |  |
		// +--|  |      +--|  |      +--|  |

		mushcell ab = avoid_beg.v[i],
		         ae = avoid_end.v[i],
		         p  = pos.v[i];
		if (ae < p) beg->v[i] = mushcell_max(beg->v[i], ae+1);
		if (ab > p) end->v[i] = mushcell_min(end->v[i], ab-1);
	}

	mush_aabb box, abox;
	mush_aabb_make_unsafe(&box, *beg, *end);
	mush_aabb_make_unsafe(&abox, avoid_beg, avoid_end);
	assert (!mush_aabb_overlaps(&box, &abox));
}
